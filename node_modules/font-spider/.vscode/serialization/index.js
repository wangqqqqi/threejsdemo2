'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decode = exports.encode = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /* eslint-disable no-new-func, no-new-wrappers, no-console */

var _objectLoops = require('./object-loops');

var _objectLoops2 = _interopRequireDefault(_objectLoops);

var _rules = require('./rules');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var REFERENCE = '@REF:';
var EXTENDS = '@EXTENDS';
var PROPERTY = '@PROPERTY';

var encode = exports.encode = function encode(target) {
  var rules = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _rules.encode;

  var now = Date.now();
  var cache = new WeakMap();
  var data = [];
  var structure = new Set([Array, Map, WeakMap, Set, WeakSet]);

  _objectLoops2.default.for(target, function (value, key, context) {
    if (value === null || typeof value !== 'object') {
      return value;
    }

    var reference = cache.get(value);
    if (typeof reference === 'number') {
      data[cache.get(context)][1][key] = `${REFERENCE}${reference}`;
      return _objectLoops2.default.continue;
    }

    reference = data.length;

    var _Object$getPrototypeO = Object.getPrototypeOf(value),
        constructor = _Object$getPrototypeO.constructor;

    var type = constructor.name;
    var extend = null;
    var clone = void 0;

    // support: class Example extends Map {}
    if (!structure.has(constructor)) {
      if (value instanceof Array) {
        extend = Array.from(value);
      } else if (value instanceof Map) {
        extend = new Map(value);
      } else if (value instanceof WeakMap) {
        extend = new WeakMap(value);
      } else if (value instanceof Set) {
        extend = new Set(value);
      } else if (value instanceof WeakSet) {
        extend = new WeakSet(value);
      }
    }

    if (extend) {
      clone = { [EXTENDS]: extend, [PROPERTY]: {} };
      var _hasOwnProperty = Object.prototype.hasOwnProperty;

      for (var i in value) {
        if (_hasOwnProperty.call(value, i) && !_hasOwnProperty.call(extend, i)) {
          clone[PROPERTY][i] = value[i];
        }
      }
    } else {
      var result = (rules[type] || rules.Object)(value, key);
      clone = Array.isArray(result) ? Array.from(result) : Object.assign({}, result);
    }

    cache.set(value, reference);
    cache.set(clone, reference);
    data.push([type, clone]);

    if (key !== null) {
      context[key] = `${REFERENCE}${reference}`; // eslint-disable-line no-param-reassign
    }
    return clone;
  });

  var time = Date.now() - now;
  return data;
};

var decode = exports.decode = function decode(data) {
  var rules = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _rules.decode;

  var now = Date.now();

  var cache = [];
  var types = new WeakMap();
  var references = new WeakMap();

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = data.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ref = _step.value;

      var _ref2 = _slicedToArray(_ref, 2);

      var index = _ref2[0];

      var _ref2$ = _slicedToArray(_ref2[1], 2);

      var type = _ref2$[0];
      var object = _ref2$[1];

      cache[index] = object;
      types.set(object, type);
      for (var key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          var _value2 = object[key];
          if (typeof _value2 === 'string' && _value2.indexOf(REFERENCE) === 0) {
            var _value2$split = _value2.split(REFERENCE),
                _value2$split2 = _slicedToArray(_value2$split, 2),
                reference = _value2$split2[1];

            var _data$reference = _slicedToArray(data[reference], 2),
                ref = _data$reference[1];

            if (!ref) {
              throw new ReferenceError(`"${key}": can not find a reference: ${reference}`);
            }

            if (!references.has(ref)) {
              references.set(ref, []);
            }

            references.get(ref).push([index, key]);
            object[key] = ref;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var extendObjects = [];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = cache.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _ref3 = _step2.value;

      var _ref4 = _slicedToArray(_ref3, 2);

      var _index = _ref4[0];
      var value = _ref4[1];

      var _type = types.get(value);
      var _object = rules[_type] ? rules[_type](value) : rules['@Unknown'](value, _type);
      if (_object !== value) {
        var _reference = references.get(value);
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = _reference[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _ref5 = _step4.value;

            var _ref6 = _slicedToArray(_ref5, 2);

            var contextIndex = _ref6[0];
            var _key = _ref6[1];

            cache[contextIndex][_key] = _object;
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        references.delete(value);
        references.set(_object, _reference);
        types.delete(value);
        types.set(_object, _type);
      }
      if (Reflect.has(_object, EXTENDS)) {
        extendObjects.push(_object);
      }
      cache[_index] = _object;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = extendObjects[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _value = _step3.value;

      var extendValue = _value[EXTENDS];
      var _type2 = types.get(_value);
      var _object2 = rules[_type2](extendValue);
      Object.assign(_object2, _value[PROPERTY]);
      if (_object2 !== _value) {
        var _reference2 = references.get(_value);
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = _reference2[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var _ref7 = _step5.value;

            var _ref8 = _slicedToArray(_ref7, 2);

            var _contextIndex = _ref8[0];
            var _key2 = _ref8[1];

            cache[_contextIndex][_key2] = _object2;
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }

        references.delete(_value);
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  var time = Date.now() - now;
  return cache[0];
};