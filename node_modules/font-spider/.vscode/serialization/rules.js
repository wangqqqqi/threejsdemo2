'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decode = exports.encode = undefined;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /* eslint-disable no-new-func, no-new-wrappers */


var encode = exports.encode = {};
var decode = exports.decode = {};

encode.Object = function (value) {
  return value;
};
decode.Object = function (value) {
  return value;
};
encode.Array = function (value) {
  return value;
};
decode.Array = function (value) {
  return value;
};
encode.Function = function (value, key) {
  return [value.toString()];
};
decode.Function = function (value) {
  return new Function(`return ${value[0]}`)();
};
encode.Map = function (value) {
  return [].concat(_toConsumableArray(value));
};
decode.Map = function (value) {
  return new Map(value);
};
decode.WeakMap = function (value) {
  return [].concat(_toConsumableArray(value));
};
decode.WeakMap = function (value) {
  return new WeakMap(value);
};
encode.Set = function (value) {
  return [].concat(_toConsumableArray(value));
};
decode.Set = function (value) {
  return new Set(value);
};
decode.WeakSet = function (value) {
  return [].concat(_toConsumableArray(value));
};
decode.WeakSet = function (value) {
  return new WeakSet(value);
};
encode.RegExp = function (value) {
  return [value.source, value.flags];
};
decode.RegExp = function (value) {
  return new RegExp(value[0], value[1]);
};
encode.Date = function (value) {
  return [value.toString()];
};
decode.Date = function (value) {
  return new Date(value[0]);
};
encode.Buffer = function (value) {
  return [JSON.stringify(value)];
};
decode.Buffer = function (value) {
  return new Buffer(JSON.parse(value[0]));
};
encode.String = function (value) {
  return [value.toString()];
};
decode.String = function (value) {
  return new String(value[0]);
};
encode.Number = function (value) {
  return [value];
};
decode.Number = function (value) {
  return new Number(value[0]);
};
encode.Boolean = function (value) {
  return [value];
};
decode.Boolean = function (value) {
  return new Boolean(value[0]);
};
// TODO Infinity

decode['@Unknown'] = function (value, type) {
  return new Proxy(value, {
    get(target, name) {
      if (Reflect.has(target, name)) {
        return Reflect.get(target, name);
      }
      throw new ReferenceError(`"${name}" does not support decoding`);
    },
    set(target, name, val) {
      Reflect.set(target, name, val);
      return true;
    }
  });
};